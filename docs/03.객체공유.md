

# 객체공유

여러 스레드를 이용한 멀티스레드 방법으로 애플리케이션을 작성하고 있다면, 객체 공유를 적절한 방법으로 해줘야합니다. 여러 개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객체를 공유하고 공개하는 방법을 알아보겠습니다.

## 1. 가시성

단일 스레드만을 사용하는 환경이라면 특정 변수에 값을 지정하고 다음번에 해당 변수의 값을 다시 읽어보면, 이전에 저장해뒀던 바로 그 값을 가져 올 수 있습니다. 

**NoVisibility 클래스**

```java
public class NoVisibility {
    private static boolean ready;
    private static int number;

    public static class ReaderThread extends Thread {
        @Override
        public void run() {
            while(!ready)
                Thread.yield();
            System.out.println(number);
        }
    }

     public static void main(String[] args) {
          new ReaderThread().start();
          number =42;
          ready = true;
      }
}
```

위에 있는 NoVisibility 클래스를 보면 동기화 작업이 되어 있지 않은 상태에서 여러 스레드가 동일한 변수를 사용 할 때 어떤 문제가 생길 수 있는지를 알 수 있습니다. 

메인 스레드와 읽기스레드가 `ready` 와 `number` 라는 변수를 공유해 사용합니다. 메인 스레드는 읽기 스레드를 실행시킨 다음  number 변수에 42라는 값을 넣고, ready 변수의 값을 true로 지정합니다. 읽기 스레드는 ready 변수의 값이 true 될 때 까지 반복문에서 기다리다가 ready 값이 true로 변경되면 number 변수의 값을 출력합니다.

일반적으로 이 클래스를 실행시켜보면 42가 나올 것이라고 예상할 수 있지만, 0이라는 값을 출력할 수 도 있고, 심지어 영원히 값을 출력하지 못하고 ready 변수의 값이 true로 바뀌기를 계속해서 기다릴 수 도 있습니다. 말하자면 메인 스레드에서 number 변수와 ready 변수에 지정한 값을 읽기 스레드에서 사용 할 수 없는 상황인데, 두 개 스레드에서 변수를 공유해 사용함에도 불구하고, 동기화 기법을 사용하지 않았기 때문입니다.

그래서 위에 클래스는 영원히 무한 반복에 빠질 수 도 있고 더 이상하게는 읽기 스레드가 메인 스레드에서 number 변수에 지정한 값 보다 ready 변수의 값을 먼저 읽어 갈 수 도 있는데, 이런 현상을 재배치(reordering)라고 합니다. 

재배치 현상은 특정 메소드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제이며, 단일 스레드로 동작할 때는 차이점을 전혀 알아챌 수 없지만 여러 스레드가 동시에 동작하는 경우에는 확연하게 나타날 수 있습니다. 

메인 스레드는 number 변수에 값을 먼저 저장하고 ready 변수에도 값을 저장하지만, 동기화되지 않은 상태이기 때문에 읽기 스레드 입장에서는 마치 ready 변수에 값이 먼저 쓰여진 이후에 number 변수에 값이 저장되는 것 처럼 순서가 바뀌어 보일 수 도 있고, 심지어는 아예 변경된 값을 읽지 못할 수도 있습니다.



### 1.1.스테일 데이터

스테일 데이터는 어떤 변수의 값을 읽으려고 할 때, 그 변수의 값이 최신 값이 아닌 상태를 말합니다.

**StaleInteger 클래스**

```java
public class StaleInteger {
    private int value;
    
    public int get() { return value; }
    public void set(int value) {this.value = value;}
}
```

> Stale 현상이 나타나는 이유 [그림]

![](https://github.com/DaeAkin/spring-multi-thread/blob/master/docs/images/%EC%8A%A4%ED%85%8C%EC%9D%BC%EC%98%88%EC%A0%9C.png?raw=true)

스테일 현상을 방지하기 위해서는 get메소드와 set 메소드 모두 동기화를 시켜줘야 합니다.

**SynchronizedInteger 클래스**

```java
public class SynchronizedInteger {
    private int value;

    public synchronized int get() { return value; }
    public synchronized void set(int value) {this.value = value;}
}
```



### 1.2.volatile 변수

volatile로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해줍니다. 특정 변수를 선언할 때 volatile 키워드를 지정하면, 컴파일러와 런타임 모두 <u>'이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치 해서는 안된다'</u> 라고 이해합니다.

volatile로 **지정된 변수는 프로세서의 레지스터에 캐시되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에** volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 **최신의 값**을 읽어갈 수 있습니다.

volatile은 위에서 살펴본 **SynchronizedInteger** 클래스와 대략 비슷한 형태로 동작한다고 이해할 수 있습니다. 그러나 volatile 변수를 사용할 때에는 아무런 락이나 동기화 기능이 동작하지 않기 때문에 synchronized를 사용한 동기화보다는 아무래도 강도가 약할 수 밖에 없습니다. 

스레드A가 volatile 변수에 값을 써넣고 스레드 B가 해당 변수의 값을 읽어 사용한다고 할 때, 스레드 B가 volatile 변수의 값을 읽고 나면 스레드 A가 변수에 값을 쓰기 전에 볼 수 있었던 모든 변수의 값을 스레드 B도 모두 볼 수 있다는 점 입니다. 따라서 메모리 가시성의 입장에서 본다면 volatile 변수를 사용하는 것과 synchronized 키워드로 특정 코드를 묶는 게 비슷한 효과를 가져오고, volatile 변수의 값을 읽고 나면 synchronized 블록에 진입하는 것과 비슷한 상태에 해당합니다. 

그러나 volatile 변수만 사용해 메모리 가시성을 확보하도록 작성한 코드는 synchronized로 직접 동기화한 코드보다 훨씬 읽기가 어렵고, 따라서 오류가 발생할 가능성도 높습니다. 

volatile 변수는 다음과 같은 상황일 때 사용하면 좋습니다.

- 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경한느 스레드가 하나만 존재
- 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않을 때 
- 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우



## 2.공개와 유출

특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개 되었다고 합니다. private이 아닌 메소드가 내부에서 생성한 객체를 리턴하거나, 다른 클래스의 메소드로 객체를 넘겨주는 경우 등이 해당 됩니다. 아니면 특정 객체를 공개해서 여러 부분에서 공유해서 사용 할 수 있도록 만들기도 하는데, 이런 경우에는 반드시 해당 객체를 동기화 해야 합니다. 만약 클래스 내부의 상태 변수를 외부에 공개해야 한다면 객체 캡슐화 작업이 물거품이 되거나 내부 데이터의 안정성을 해칠 수 있습니다. 따라서 객체가 안정적이지 않은 상태에서 공개하면 스레드 안정성에 문제가 생길 수 있습니다. 

이처럼 의도적으로 공개시키지 않았지만 외부에서 사용할 수 있게 공개된 경우를 유출 상태라고 합니다.

**객체가 공개 됨**

```java
public static Set<Secret> knownSecrets;

public void initialize() { 
	knownSecrets = new HashSet<Secret>();
}
```

그런데 특정 객체가 공개되면, 그와 관련된 다른 객체까지 덩달아 공개하게 되는 경우도 있습니다. 만약 위에 knownSecrets 변수에게 Secret 객체를 넣는다면, 그 객체도 공개되는 셈 입니다.



```java
public class UnsafeStates {
    private String[] states = new String[] {
        "AA","BB","CC"
    };
    // 내부적으로 사용할 변수를 외부에 공개하는건 좋지 않음!
    public String[] getStates() {return  states;}
}
```

private 키워드를 지정해 숨겨져 있는 states 변수를 다음과 같은 방법으로 공개하면 getStates() 메소드를 호출한 측에서 숨겨진 states 변수의 값을 직접 변경할 수 있기 때문에 권장하는 방법은 아닙니다. 그래서 states라는 변수는 getStates 메소드를 통해 외부에 공개될 수 있기 때문에, states 변수는 유출 상태에 놓여 있다고 볼 수 있습니다.



## 3.스레드 한정

변경 가능한 객체를 공유해 사용하는 경우에는 항상 동기화를 시켜야하며, 특정 객체를 단일 스레드에서만 활용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없습니다. 이처럼 객체를 스레드를 한정하는 방법으로도 스레드 안정성을 확보할 수 있습니다.

스레드 한정 기법을 사용하는 사례는 JDBC의 Connection 객체를 폴링해 사용하는 경우 입니다. JDBC 표준에 따르면 이 Connection 객체가 반드시 스레드 안정성을 확보하고 있어야 하는 건 아닙니다. 일반적인 서버 애플리케이션을 보면 풀에서 DB 연결을 확보하고, 확보한 DB 연결로 요청 하나를 처리한 다음 사용한 연결을 다시 반환하는 과정을 거칩니다. 서블릿 요청은 대부분 단일 스레드에서 동기적으로 처리하며, **DB 풀은 한쪽에서 DB 연결을 사용하는 동안에는 해당 연결을 다른 스레드가 사용하지 못하기 때문에,** 공유하는 Connection 객체를 풀로 관리하면 특정 Connection을 한 번에 하나 이상의 스레드가 사용하지 못하도록 한정할 수 있다. 

### 3.1.스택 한정

스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특병한 경우의 스레드 한정 기법이라고 할 수 있습니다. **로컬 변수는 현재 실행 중인 스레드 내부의 스택에만 존재**하기 때문에 **스레드 내부의 스택은 외부 스레드에서 볼 수가 없습니다.** 

```java
public int someVar() { 
	int number = 1;	
	return number;
}
```

위와 같이 기본 변수형을 사용하는 로컬 변수는 일부러 하려고 해도 스택 한정 상태를 깰 수 없습니다. 기본 변수형은 객체와 같이 참조되는 값이 아니기 때문인데, 이처럼 기본 변수형을 사용하는 로컬 변수는 언어적으로 스택 한정 상태가 보장됩니다.



### 3.2.ThreadLocal

스레드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀 더 형식적인 방법으로 ThreadLocal이 있습니다. ThreadLocal 클래스에는 get과 set 메소드가 있는데 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리해 줍니다. 쉽게 말해 현재 실행 중인 스레드가 임시로 값을 저장해서 사용할 때 사용합니다.

스레드 로컬 변수는 변경 가능한 싱글턴이나 전역 병수 등을 기반으로 설계되어 있는 구조에서 변수가 임의로 공유되는 상황을 막기 위해 사용하는 경우가 많습니다. 예를 들어 단일 스레드로 동작하는 애플리케이션에서 데이터베이스에 접속할 때 매번 Connection 인스턴스를 만들어 내는 부담을 줄이고자 프로그램 시작 시점에 Connection 인스턴스를 하나 만들어 전역 변수에 넣어두고 계속해서 사용하는 방법을 사용하기도 합니다. 하지만 JDBC 연결은 스레드에 안전하지 안전하지 않기 때문에 멀티스레드 애플리케이션에서 적절한 동기화 없이 연결 객체를 전역 변수로 만들어 사용하면 애플리케이션 역시 스레드에 안전하지 않게 됩니다. 하지만 다음과 같이 스레드 로컬을 이용하면 쉽게 해결할 수 있습니다.

```java
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
  public Connection initialValue() { 
  	return DriverManager.getConnection(DB_URL);
  }
};

public static Connection getConnection() {
  return connectionHolder.get();
}
```



## 4.불변성

직접적으로 객체를 동기화하지 않고도 안전하게 사용할 수 있는 방법 가운데 마지막으로 알아볼 내용은 바로 불변(immutable)객체입니다. 지금까지 살펴봤던 것처럼 **스테일 상태** 변수를 사용하거나, 여러 스레드가 동시에 변수에 접근하는 등, 예측 할 수 없는 방향으로 변경 가능한 값을 동시에 사용하려 하기 때문에 발생 했습니다. 그런데 만약 객체의 상태를 변경할 수 없다면 지금 가지 발생했던 문제들은 전부 사라 집니다.

**불변 객체**는 맨 처음 생성되는 시점을 제외하고 그 **값이 전혀 바뀌지 않는 객체**를 말합니다. 다시 말해 불변 객체의 변하지 않는 값은 처음 만들어질 때 생성 메소드에서 설정되고, 상태를 바꿀 수 없기 때문에 맨 처음 설정된 값이 **절대** 바뀌지 않습니다. 따라서 불변 객체는 그 태생부터 스레드에 안전한 상태 입니다.

#### 불변의 조건

- 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.
- 내부의 모든 변수는 final로 설정 돼야 한다.
- 적절한 방법으로 생성돼야 한다.